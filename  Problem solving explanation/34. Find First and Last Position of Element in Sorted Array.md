## Binary Search – Main
This problem, **like Question 33**, requires an **O(log n)** solution. Therefore, I use **binary search**, since linear search has a time complexity of **O(n)**. </br>

This function updates the minimum or maximum index by calculating the middle index and comparing the middle value with the target value. </br>

``` python
    mid = (max_idx+min_idx) //2
    if nums[mid] > target:
        max_idx = max_idx -1
    elif nums[mid] < target:
        min_idx = min_idx +1
    else:
        return mid
```

## Difference this question function and current question?
In this question, the array may contain multiple occurrences of the target value. </br>
When the middle index reaches a value equal to the target, I need to determine the starting and ending indices of the target’s range. </br>
To do this, I implement a mechanism that expands from the middle index to identify the leftmost and rightmost positions where the value equals the target. </br>

``` python
if nums[mid] == taraget:
    if start_idx > mid:
        start_idx = mid
    if end_idx < mid:
        end_idx = mid
                
    for i in range(mid-1,-1,-1):
        if nums[i] == target:
            start_idx = i
        else:
            break
    
    for k in range(mid+1, len(nums)):
        if nums[k] == target:
            end_idx = k
        else:
            break
```

This way, I can find the first and last positions of the target value in the sorted array.


