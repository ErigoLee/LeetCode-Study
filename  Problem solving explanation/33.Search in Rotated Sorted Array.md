## Binary Search - Main
This problem requires an O(log n) solution. Therefore, I use binary search, since linear search has a time complexity of O(n). </br>
This function updates the minimum or maximum index by calculating the middle index and comparing the middle value with the target value. </br>

``` python
    mid = (max_idx+min_idx) //2
    if nums[mid] > target:
        max_idx = max_idx -1
    elif nums[mid] < target:
        min_idx = min_idx +1
    else:
        return mid
```

## Difference this question function and current question?
In this question, the input array may be **left-rotated by more than 0 indices.** Because of this, I first need to determine the indices of the minimum and maximum values. </br>
``` python
    max_num = max(nums)
    max_idx = nums.index(max_num)
    min_num = min(nums)
    min_idx = nums.index(min_num)
```

Additionally, it is possible that the index of the maximum value is **lower than** the index of the minimum value. To handle this case, I use a boolean variable called `flag`.</br>

* If `flag` is `False`, it indicates that the index of the maximum is lower than the index of the minimum. </br>
* In this situation, I calculate the middle index as follows: </br>
``` python
    mid = (min_idx-max_idx)//2
```

However, when the index of the maximum reaches the **last index of the array**, or when the index of the minimum reaches **0**, I change the value of `flag` to `True`. After that, I switch to a different method for calculating the middle index.
``` python
    if max_idx == nums_max_idx or min_idx == 0:
        flag = True
    mid = (max_idx+min_idx)//2
```

Even when the index of the maximum becomes the same as the index of the minimum, I exit the `while` loop. I assume that when both indices are the same, the value at that index is likely to be the target. Therefore, I use the following condition:
``` python
    if min_idx == max_idx and nums[min_idx] == target:
        return min_idx
    else:
        return -1
```